{
	"noir_version": "0.27.0+606ff4448571b0cfe4b92420c766c4239a4b23a0",
	"hash": 3271347688557974391,
	"abi": {
		"parameters": [
			{
				"name": "range",
				"type": {
					"kind": "array",
					"length": 2,
					"type": { "kind": "integer", "sign": "unsigned", "width": 64 }
				},
				"visibility": "public"
			},
			{ "name": "operator", "type": { "kind": "field" }, "visibility": "public" },
			{
				"name": "hashed_message",
				"type": {
					"kind": "array",
					"length": 32,
					"type": { "kind": "integer", "sign": "unsigned", "width": 8 }
				},
				"visibility": "public"
			},
			{
				"name": "signature",
				"type": {
					"kind": "array",
					"length": 64,
					"type": { "kind": "integer", "sign": "unsigned", "width": 8 }
				},
				"visibility": "private"
			},
			{
				"name": "publicKey",
				"type": {
					"kind": "struct",
					"path": "ecrecover::PublicKey",
					"fields": [
						{
							"name": "pub_x",
							"type": {
								"kind": "array",
								"length": 32,
								"type": { "kind": "integer", "sign": "unsigned", "width": 8 }
							}
						},
						{
							"name": "pub_y",
							"type": {
								"kind": "array",
								"length": 32,
								"type": { "kind": "integer", "sign": "unsigned", "width": 8 }
							}
						}
					]
				},
				"visibility": "private"
			},
			{
				"name": "guess",
				"type": {
					"kind": "struct",
					"path": "coordinates::Coordinate",
					"fields": [
						{
							"name": "latitude",
							"type": {
								"kind": "struct",
								"path": "coordinates::Latitude",
								"fields": [
									{ "name": "negative", "type": { "kind": "boolean" } },
									{
										"name": "integral",
										"type": { "kind": "integer", "sign": "signed", "width": 32 }
									},
									{
										"name": "fractional",
										"type": { "kind": "integer", "sign": "unsigned", "width": 32 }
									}
								]
							}
						},
						{
							"name": "longitude",
							"type": {
								"kind": "struct",
								"path": "coordinates::Longitude",
								"fields": [
									{ "name": "negative", "type": { "kind": "boolean" } },
									{
										"name": "integral",
										"type": { "kind": "integer", "sign": "signed", "width": 32 }
									},
									{
										"name": "fractional",
										"type": { "kind": "integer", "sign": "unsigned", "width": 32 }
									}
								]
							}
						}
					]
				},
				"visibility": "private"
			},
			{
				"name": "actual",
				"type": {
					"kind": "struct",
					"path": "coordinates::Coordinate",
					"fields": [
						{
							"name": "latitude",
							"type": {
								"kind": "struct",
								"path": "coordinates::Latitude",
								"fields": [
									{ "name": "negative", "type": { "kind": "boolean" } },
									{
										"name": "integral",
										"type": { "kind": "integer", "sign": "signed", "width": 32 }
									},
									{
										"name": "fractional",
										"type": { "kind": "integer", "sign": "unsigned", "width": 32 }
									}
								]
							}
						},
						{
							"name": "longitude",
							"type": {
								"kind": "struct",
								"path": "coordinates::Longitude",
								"fields": [
									{ "name": "negative", "type": { "kind": "boolean" } },
									{
										"name": "integral",
										"type": { "kind": "integer", "sign": "signed", "width": 32 }
									},
									{
										"name": "fractional",
										"type": { "kind": "integer", "sign": "unsigned", "width": 32 }
									}
								]
							}
						}
					]
				},
				"visibility": "private"
			}
		],
		"param_witnesses": {
			"actual": [{ "start": 169, "end": 175 }],
			"guess": [{ "start": 163, "end": 169 }],
			"hashed_message": [{ "start": 3, "end": 35 }],
			"operator": [{ "start": 2, "end": 3 }],
			"publicKey": [{ "start": 99, "end": 163 }],
			"range": [{ "start": 0, "end": 2 }],
			"signature": [{ "start": 35, "end": 99 }]
		},
		"return_type": null,
		"return_witnesses": []
	},
	"bytecode": "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",
	"debug_symbols": "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",
	"file_map": {
		"32": {
			"source": "mod hash;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod grumpkin_scalar;\nmod grumpkin_scalar_mul;\nmod scalar_mul;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\nmod internal;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n",
			"path": "std/lib.nr"
		},
		"47": {
			"source": "use dep::std;\n\nstruct PublicKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nimpl PublicKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PublicKey {\n        PublicKey { pub_x, pub_y }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PublicKey {\n        let (pub_x, pub_y) = split_u8_64_unconstrained(pub_key);\n\n        PublicKey { pub_x, pub_y }\n    }\n\n    pub fn to_eth_address(self) -> Field {\n        let pub_key = u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(self, signature: [u8; 64], hashed_message: [u8; 32]) -> Field {\n        let valid_signature = std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message);\n        assert(valid_signature, \"Invalid signature\");\n        let addr = self.to_eth_address();\n        addr\n    }\n}\n\nunconstrained pub fn split_u8_64_unconstrained(arr: [u8; 64]) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    }\n\n    (arr_a, arr_b)\n}\n\nunconstrained pub fn u8_32_to_u8_64_unconstrained(arr_a: [u8; 32], arr_b: [u8; 32]) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n",
			"path": "/Users/envoy1084/Projects/Important/zk-guesser/packages/circuits/src/ecrecover.nr"
		},
		"49": {
			"source": "use dep::std;\nmod ecrecover;\nmod coordinates;\n\n#[export]\nunconstrained fn get_distance(c1: coordinates::Coordinate, c2: coordinates::Coordinate) -> u64 {\n    coordinates::distance(c1, c2)\n}\n\nfn main(\n    range: pub [u64; 2],\n    operator: pub Field,\n    hashed_message: pub [u8; 32],\n    signature: [u8; 64],\n    publicKey: ecrecover::PublicKey,\n    guess: coordinates::Coordinate,\n    actual: coordinates::Coordinate\n) {\n    let recovered = publicKey.ecrecover(signature, hashed_message);\n    println(recovered);\n    assert(recovered == operator, \"ZKGuesser: Invalid Signature\");\n\n    let distance = get_distance(guess, actual);\n    assert(distance >= range[0], \"ZKGuesser: Distance out of range\");\n    assert(distance <= range[1], \"ZKGuesser: Distance out of range\");\n}\n\n#[test]\nfn test_guess() {\n    let range = [0, 1000];\n    let c1 = coordinates::Coordinate {\n        latitude: coordinates::Latitude { negative: false, integral: 52, fractional: 52 },\n        longitude: coordinates::Longitude { negative: false, integral: 13, fractional: 4050 }\n    };\n\n    let c2 = coordinates::Coordinate {\n        latitude: coordinates::Latitude { negative: false, integral: 51, fractional: 5047 },\n        longitude: coordinates::Longitude { negative: true, integral: 0, fractional: 1278 }\n    };\n\n    let hashed_message = [\n        106, 66, 40, 170, 243, 63, 60, 17,\n        56, 150, 90, 247, 119, 140, 24, 98,\n        183, 76, 104, 12, 120, 164, 239, 194,\n        63, 35, 27, 195, 193, 110, 80, 6\n    ];\n\n    let signature = [\n        238, 40, 53, 223, 85, 186, 149, 138, 146, 3, 11,\n        177, 242, 12, 241, 111, 50, 97, 95, 64, 246, 175,\n        94, 161, 189, 107, 13, 229, 61, 221, 34, 54, 51,\n        178, 47, 31, 48, 45, 218, 68, 130, 26, 16, 205,\n        224, 81, 82, 188, 218, 175, 255, 197, 188, 225, 228,\n        201, 184, 92, 195, 71, 113, 219, 141, 107\n    ];\n    let publicKey = ecrecover::PublicKey {\n        pub_x: [\n            224, 117, 65, 44, 181, 126, 126, 206,\n            100, 136, 127, 140, 111, 57, 8, 6,\n            16, 68, 199, 139, 215, 145, 174, 95,\n            86, 106, 121, 40, 250, 45, 18, 86\n        ],\n        pub_y: [\n            93, 241, 76, 152, 89, 186, 145, 163,\n            91, 68, 228, 13, 213, 15, 15, 133,\n            185, 64, 236, 186, 59, 140, 113, 57,\n            87, 136, 133, 137, 109, 152, 133, 57\n        ]\n    };\n\n    main(\n        range,\n        0x0009D5d42d946c42E8138D7EfE483118dbCA414B,\n        hashed_message,\n        signature,\n        publicKey,\n        c1,\n        c2\n    );\n}\n\n#[test]\nfn test_key_to_address() {\n    let pub_key_x = [\n        57, 75, 55, 39, 97, 142, 247, 86,\n        26, 215, 46, 10, 196, 46, 217, 135,\n        26, 114, 151, 135, 65, 26, 58, 81,\n        34, 20, 128, 84, 89, 69, 113, 80\n    ];\n    let pub_key_y = [\n        194, 204, 236, 13, 142, 215, 50,\n        113, 123, 172, 198, 209, 211, 249,\n        162, 5, 109, 90, 233, 85, 81,\n        127, 75, 191, 251, 191, 103, 225,\n        206, 206, 211, 50\n    ];\n\n    let key = ecrecover::PublicKey { pub_x: pub_key_x, pub_y: pub_key_y };\n    let addr = key.to_eth_address();\n    assert(addr == 0x73979880be5A498fC205D4Ad7EB517d9B2e03c9d);\n}\n\n#[test]\nfn test_verifySig() {\n    let pub_key_x = [\n        57, 75, 55, 39, 97, 142, 247, 86,\n        26, 215, 46, 10, 196, 46, 217, 135,\n        26, 114, 151, 135, 65, 26, 58, 81,\n        34, 20, 128, 84, 89, 69, 113, 80\n    ];\n    let pub_key_y = [\n        194, 204, 236, 13, 142, 215, 50,\n        113, 123, 172, 198, 209, 211, 249,\n        162, 5, 109, 90, 233, 85, 81,\n        127, 75, 191, 251, 191, 103, 225,\n        206, 206, 211, 50\n    ];\n\n    let signature = [\n        191, 21, 84, 47, 7, 134, 56, 201, 195, 27, 124,\n        255, 117, 104, 176, 211, 125, 65, 43, 101, 47, 5,\n        74, 223, 246, 18, 164, 19, 22, 15, 148, 97, 17,\n        156, 245, 230, 49, 207, 16, 142, 6, 254, 75, 255,\n        230, 54, 52, 161, 84, 138, 253, 252, 75, 146, 30,\n        193, 63, 156, 134, 225, 7, 52, 210, 76\n    ];\n    let hashed_message = [\n        29, 189, 253, 193, 67, 240, 35, 230,\n        34, 55, 70, 114, 37, 234, 124, 228,\n        108, 45, 102, 115, 115, 181, 253, 190,\n        165, 57, 67, 99, 118, 95, 55, 104\n    ];\n\n    let key = ecrecover::PublicKey { pub_x: pub_key_x, pub_y: pub_key_y };\n    assert(key.ecrecover(signature, hashed_message) == 0x73979880be5A498fC205D4Ad7EB517d9B2e03c9d);\n}\n",
			"path": "/Users/envoy1084/Projects/Important/zk-guesser/packages/circuits/src/main.nr"
		}
	},
	"names": ["main"]
}
